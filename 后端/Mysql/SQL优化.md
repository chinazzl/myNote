### SQL优化

#### 如何定位以及SQL语句的性能问题

对于低性能的SQL语句的定位， 重要也是 有效的方法就是使用执行计划， MySQL提供了explain命令来
查看语句的执行计划。 我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行
执行的过程中都会做很多相关的优化，对于查询语句，最重要的优化方式就是使用索引。 而执行计划，
就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用
的索引的相关信息等。  

```sql
explain select first_name  from actor_test where last_name = 'GUINESS' and last_update > '2006-01-01 00:00:00' and actor_id = 1;
```

1、type

1. system：表仅有一行，基本用不到；
2. const：表最多一行数据配合，主键查询时触发较多；
3. eq_ref：对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的联接类型，除了const类型；
4. ref：对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取；
5. range：只检索给定范围的行，使用一个索引来选择行。当使用=、<>、>、>=、<、<=、IS NULL、<=>、BETWEEN或者IN操作符，用常量比较关键字列时，可以使用range；
6. index：该联接类型与ALL相同，除了只有索引树被扫描。这通常比ALL快，因为索引文件通常比数据文件小；
7. all：全表扫描；
   性能排名：system > const > eq_ref > ref > range > index > all。
   实际sql优化中，最后达到ref或range级别。

2、Extra常用关键字

* Using index：只从索引树中获取信息，而不需要回表查询；
* Using where：WHERE子句用于限制哪一个行匹配下一个表或发送到客户。除非你专门从表中索取或检查所有行，如果Extra值不为Using where并且表联接类型为ALL或index，查询可能会有一些错误。需要回表查询。
* Using temporary：mysql常建一个临时表来容纳结果，典型情况如查询包含可以按不同情况列出列的GROUP BY和ORDER BY子句时；

#### 字段定义为not null

null值会占用更多的字节，且会在程序中造成很多与预期不符的情况

#### varchar和char的区别

**char的特点**
char表示定长字符串，长度是固定的；如果插入数据的长度小于char的固定长度时，则用空格填充；
因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多
余的空间，是空间换时间的做法；
对于char来说， 多能存放的字符个数为255，和编码无关。

**varchar的特点**
varchar表示可变长字符串，长度是可变的；
插入的数据是多长，就按照多长来存储；
varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间
换空间的做法；
对于varchar来说， 多能存放的字符个数为65532 总之，结合性能角度（char更快）和节省磁盘空间角
度（varchar更小），具体情况还需具体来设计数据库才是妥当的做法。  

#### int(20)中20的涵义

是指显示字符的长度。20表示 大显示宽度为20，但仍占4字节存储，存储范围不变；
不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示  

#### UNION与UNIONALL的区别？

如果使用UNION ALL，不会合并重复的记录行

**效率 UNION 高于 UNION ALL**   

#### 查询过程中数据访问优化

访问数据太多导致查询性能下降确定应用程序是否在检索大量超过需要的数据，可能是太多行或列确认
MySQL服务器是否在分析大量不必要的数据行避免犯如下SQL语句错误
查询不需要的数据。

解决办法：使用limit解决
多表关联返回全部列。

解决办法：指定列名
总是返回全部列。解决办法：避免使用SELECT * 重复查询相同的数据。解决办法：可以缓存数据，下次
直接读取缓存是否在扫描额外的记录。

解决办法：
使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优
化：
使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。
改变数据库和表的结构，修改数据表范式
重写SQL语句，让优化器可以以更优的方式执行查询。  

#### count

count()会忽略所有的列，直接统计所有的列数，不要使用count(列明)在MyIsam中，没有任何where条件的count()非常快，在InnoDB中，使用id作为主键查询count和MyIsam差不多性能速度。

#### 优化关联查询

确定ON或者using子句是否有索引

确保Group by和order by 只有一个表中的列，这样mysql才有可能使用索引。

### 尽量使用数值替换字符串类型

例如：性别（sex）：0代表女，1代表男；数据库没有布尔类型，mysql推荐使用tinyint
理由：

1. 因为引擎在处理查询和连接时会逐个比较字符串中每一个字符
2. 而对于数字型而言只需要比较一次就够了
3. 字符会降低查询和连接的可能性，并会增加存储开销。

### inner Join、left join、right join优先使用 inner Join

三种连接如果结果相同，优先使用inner join，如果使用left  join 左边表尽量小。

* inner join 内连接，只保留两张表中完全匹配的结果；
* left join 会返回左表所有的行，即使在右表中 没有匹配的记录。
* right join会返回右表所有的行，即使在左表中没有匹配的记录；

### 清空表时优先使用truncate

truncate table在功能上与不带 where子句的 delete语句相同：二者均删除表中的全部行。但 truncate table比 delete速度快，且使用的系统和事务日志资源少。

delete语句每次删除一行，并在事务日志中为所删除的每行记录一项。truncate table通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。

truncate table删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 drop table语句。

对于由 foreign key约束引用的表，不能使用 truncate table，而应使用不带  where子句的 DELETE 语句。由于 truncate table不记录在日志中，所以它不能激活触发器。

truncate table不能用于参与了索引视图的表。

### 表连接不宜太多，索引不宜太多，一般5个以内

表连接不宜太多，一般5个以内

关联的表个数越多，编译的时间和开销也就越大
每次关联内存中都生成一个临时表
应该把连接表拆开成较小的几个执行，可读性更高
如果一定需要连接很多表才能得到数据，那么意味着这是个糟糕的设计了
阿里规范中，建议多表联查三张表以下
2、索引不宜太多，一般5个以内

索引并不是越多越好，虽其提高了查询的效率，但却会降低插入和更新的效率；
索引可以理解为一个就是一张表，其可以存储数据，其数据就要占空间；
索引表的数据是排序的，排序也是要花时间的；
insert或update时有可能会重建索引，如果数据量巨大，重建将进行记录的重新排序，所以建索引需要慎重考虑，视具体情况来定；
一个表的索引数最好不要超过5个，若太多需要考虑一些索引是否有存在的必要；

#### 优化where子句

1. 避免在where子句中使用对null进行判断，否则会造成全表扫描，可以设置默认值
2. 避免在where子句中使用!=或<>，否则放弃索引而进行全表扫描
3. 避免在where子句中使用or连接条件，否则导致放弃使用索引而进行全表扫描，可以使用UNION进行拼接
4. in，not in 会导致全表扫描
5. like关键字`%xx%`不使用索引，会导致全表扫描
6. 避免在where子句中对字段使用计算表达式，会使列全表扫描不使用索引
7. 避免在where子句中对字段进行函数操作，会导致放弃使用索引而全表扫描
