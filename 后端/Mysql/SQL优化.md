### SQL优化

#### 如何定位以及SQL语句的性能问题

对于低性能的SQL语句的定位， 重要也是 有效的方法就是使用执行计划， MySQL提供了explain命令来
查看语句的执行计划。 我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行
执行的过程中都会做很多相关的优化，对于查询语句，最重要的优化方式就是使用索引。 而执行计划，
就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用
的索引的相关信息等。  

#### 字段定义为not null

null值会占用更多的字节，且会在程序中造成很多与预期不符的情况

#### varchar和char的区别

**char的特点**
char表示定长字符串，长度是固定的；如果插入数据的长度小于char的固定长度时，则用空格填充；
因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多
余的空间，是空间换时间的做法；
对于char来说， 多能存放的字符个数为255，和编码无关。

**varchar的特点**
varchar表示可变长字符串，长度是可变的；
插入的数据是多长，就按照多长来存储；
varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间
换空间的做法；
对于varchar来说， 多能存放的字符个数为65532 总之，结合性能角度（char更快）和节省磁盘空间角
度（varchar更小），具体情况还需具体来设计数据库才是妥当的做法。  

#### int(20)中20的涵义  

是指显示字符的长度。20表示 大显示宽度为20，但仍占4字节存储，存储范围不变；
不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示  

#### UNION与UNIONALL的区别？  

如果使用UNION ALL，不会合并重复的记录行
如果使用UNION ALL，不会合并重复的记录行
**效率 UNION 高于 UNION ALL**   

#### 查询过程中数据访问优化

访问数据太多导致查询性能下降确定应用程序是否在检索大量超过需要的数据，可能是太多行或列确认
MySQL服务器是否在分析大量不必要的数据行避免犯如下SQL语句错误
查询不需要的数据。

解决办法：使用limit解决
多表关联返回全部列。

解决办法：指定列名
总是返回全部列。解决办法：避免使用SELECT * 重复查询相同的数据。解决办法：可以缓存数据，下次
直接读取缓存是否在扫描额外的记录。

解决办法：
使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优
化：
使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。
改变数据库和表的结构，修改数据表范式
重写SQL语句，让优化器可以以更优的方式执行查询。  

#### count

count()会忽略所有的列，直接统计所有的列数，不要使用count(列明)在MyIsam中，没有任何where条件的count()非常快，在InnoDB中，使用id作为主键查询count和MyIsam差不多性能速度。

#### 优化关联查询

确定ON或者using子句是否有索引

确保Group by和order by 只有一个表中的列，这样mysql才有可能使用索引。

#### 优化where子句

1. 避免在where子句中使用对null进行判断，否则会造成全表扫描，可以设置默认值
2. 避免在where子句中使用!=或<>，否则放弃索引而进行全表扫描
3. 避免在where子句中使用or连接条件，否则导致放弃使用索引而进行全表扫描，可以使用UNION进行拼接
4. in，not in 会导致全表扫描
5. like关键字`%xx%`不使用索引，会导致全表扫描
6. 避免在where子句中对字段使用计算表达式，会使列全表扫描不使用索引
7. 避免在where子句中对字段进行函数操作，会导致放弃使用索引而全表扫描
