## 事务

### 事务的特性

1. 原子性：事务时最小的执行单位，不允许进行分割。要么全部成功，要么全部失败。
2. 一致性：事务的执行前后，数据保持一致，多个事务对同一个数据读取的结果是相同的
3. 隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间的数据库是独立的。
4. 持久性：一个事务被提交后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

### 脏读、不可重复读、幻读

1. 脏读：一个事务读了另一个事务没有提交的数据。
2. 不可重复读：一个事务执行查询的过程中，如果没有加读锁，另一个事务修改了查询的这条记录，前面的事务则会查询的结果导致前后不一致。
3. 幻读：一个事务查询前后的笔数不一致。一个事务条件查询了几条数据，这个时候另一个事务对这个查询条件内进行新增了几条数据。前面的事务再次进行查询的时候，就会发现多了几列数据。

### 事务的隔离级别

1. 读未提交(READ_UNCOMMIT)
2. 读已提交(READ_COMMIT)
3. 可重复读(REPEATABLE_READ)
4. 串行化(SERIALIZABLE)

**Mysql默认采用的是REPEATABLE_READ隔离级别，Oracle默认采用的是READ_COMMIT隔离级别，分布式环境InnoDB存储引擎的时候一般会用到SERIALIZABLE隔离级别**

### Spring的事务处理

#### 传播行为

| 传播行为                  | 含义                                                         |
| ------------------------- | ------------------------------------------------------------ |
| PROPAGATION_REQUIRED      | 表示当前方法必须在食物中，如果当前事务存在，方法将在该事务中运行，否则会启动一个新事务。 |
| PROPAGATION_SUPPORT       | 表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中进行。 |
| PROPAGATION_MANDATORY     | 表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常。 |
| PROPAGATION_REQUIRED_NEW  | 表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager |
| PROPAGATION_NOT_SUPPORTED | 表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager |
| PROPAGATION_NEVER         | 表示当前方法不应该运行在事务上下文中。如果当前征友一个事务在运行，则会抛出异常。 |
| PROPAGATION_NESTED        | 表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套事务可以独立于当前事务进行单独的提交或回滚。如果当前事务不存在，那么其行为与PROPAGATION_REQUIRED一样。 |

