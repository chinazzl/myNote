## 锁

> 当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来
> 保证访问的次序，锁机制就是这样的一个机制。
> 就像酒店的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情况，而在房间上装上锁，申请
> 到钥匙的人才可以入住并且将房间锁起来，其他人只有等他使用完毕才可以再次使用  

### 隔离级别与锁的关系

在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修
改的数据上的排他锁冲突
在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；
在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须
等待事务执行完毕以后才释放共享锁。
SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完
成。  

#### 按照锁的粒度分数据库锁有哪些？

在关系型数据库中，可以按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和
页级锁(BDB引擎 )。
MyISAM和InnoDB存储引擎使用的锁：  

- MyISAM 使用的是表级锁

- InnoDB使用的是行级锁和表级锁，默认为行级锁。InnoDB的行锁使用
  
  ```sql
  select * from table_with_index where id = 1 for update;
  ```
1. 行级锁：行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。
   特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低 ，并发度高
2. 表级锁：表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。
   特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，
   并发度最低。  
3. 页级锁：页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。
   特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和
   行锁之间，并发度一般  

#### 按照锁的类别

1. 共享锁：又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。  
2. 排他锁：又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。  

### 数据库的乐观锁和悲观锁是什么？怎么实现的？

> 数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏
> 事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并
> 发控制主要采用的技术手段。  

1. 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁
   起来，直到提交事务。
   
   实现方式：使用数据库中的锁机制  
   
   - 排他锁
   
   ```sql
   set autocommit=0;
   # 设置完autocommit后，我们就可以执行我们的正常业务了。具体如下： 
   # 1. 开始事务
   begin;/begin work;/start transaction; (三者选一就可以) 
   # 2. 查询表信息
   select status from TABLE where id=1 for update; 
   # 3. 插入一条数据
   insert into TABLE (id,value) values (2,2); 
   # 4. 修改数据为
   update TABLE set value=2 where id=1; 
   # 5. 提交事务
   commit;/commit work;
   ```
   
   - 共享锁：read lock，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。
   
          如果事务T对A加上共享锁后，则其他事务只能对A再加上共享锁，不能加排他锁。获得共享锁的事务只能读取数据不能修改数据。
   
   ```sql
   begin; /begin work;/start transaction(三选一)
   SELECT * FROM TABLE WHERE ID = 1 LOCK IN SHARE MODE;        
   ```
   
           然后在另一个查询窗口中，对id为1的数据进行更新
   
   ```sql
   UPDATE TABLE SET NAME = 'XXX' WHERE ID = 1;        
   ```
   
   

2. 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。
   
   实现方式：乐一般会使用版本号机制或CAS算法实现  

### 死锁

是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象。

解除死锁的方式：

```sql
-- 查询是否锁表
show open tables where In_use > 0;
-- 查询进程
show processlist;
-- 杀死进程Id
kill id;
```

第二种：

```sql
-- 查询当前事务
SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;
-- 查看当前锁定的事务
SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS
--查看当前等锁的事务
SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;
-- 杀死进程
kill 线程id;
```