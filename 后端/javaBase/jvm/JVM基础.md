## JVM相关

### java运行区域

- 程序计数器（Program Counter Register）：当前线程执行字节码的行号解释器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条字节码的指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成。
- Java虚拟机栈（Java Virtual Machine Stack）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
- 本地方法栈（Native Method Stack）：与虚拟机栈的作用一样，只不过虚拟机栈是服务Java方法的，而本地方法栈是为虚拟机调用Native方法服务的。
- Java堆（Java Heap）：Java虚拟机中内存最大的一块，是被所有的线程共享的，几乎所有对象实例都在这里分配内存。
- 方法区（Method Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。

### 深拷贝、浅拷贝

- 浅拷贝：只是增加了一个指针指向已经存在的内存地址
- 深拷贝：是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存。  

### GC 垃圾回收

#### GC回收基本原理：

对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况，通常GC采用有向图的方式记录和管理堆中的所有对象，GC负责回收这些内存空间。程序员可以手动执行system.gc()，通知GC运行。

#### 垃圾回收动作何时执行？

- 当年轻代内存满了时，会引发一次普通的GC，该 GC仅回收年轻代。**需要强调的是，年轻代满是指Eden代满，Survivor满不会引发GC**
- 当老年代满时会引发Full GC ，Full GC将会同时回收年轻代、老年代
- 当永久代满时也会引发Full GC，会导致Class、Method元信息卸载。

**何时会抛出OutOfMemoryException，并不是内存被耗空的时候才抛出**

1. JVM98%的时间都花费在内存的回收
2. 每次回收的内存小于2%

#### FullGC触发场景

1. System.gc()
2. 年代晋升失败，比如eden区存活对象晋升到S区放不下，又尝试直接晋升Old区又放不下，就会触发FullGC
3. CMS的Concurrent-Mode-Failure 由于CMS回收过程中主要分为四步：

​    1.CMS initial mark
​    2.CMS Concurrent mark
​    3.CMS remark
​    4.CMS Concurrent sweep。在2中gc线程与用户线程同时执行，那么用户线程依旧可 能同时产生垃圾， 
​    如果这个垃圾较多无法放入预留的空间就会产生CMS-Mode-Failure， 切换 为SerialOld单线程做mark- 
​    sweep-compact。

4. 新生代晋升的平均大小大于老年代的剩余空间（为了避免新生代晋升老年代失败）当使用G1，CMS时，Full GC发生的时候是Serial + SerialOld。当使用ParaOld时，FullGC发生的时候是ParallNew+SerialOld.

#### 如何判断对象是否可以回收

1. 引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器+1，引用被释放时计数-1，当计数器为0时就可以回收。
2. 可达性分析算法：从GC  Roots开始 向下搜索，搜索所走过的路径成为引用链。当一个对象到GC Root没有任何引用链时，证明对象时可以被回收的。

#### JVM垃圾回收算法

1. 标记-清除算法：标记无用对象，然后进行清除回收。
   - 缺点：效率低，无法清除垃圾碎片
2. 标记-复制算法：按照容量划分两个一样的大小相等的内存区域，当一块用完的时候将活着的对象复制到另外一块上，然后再把已使用饿内存空间一次清理掉 。
   - 缺点：内存使用效率不高，只有原来的一半
3. 标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除端边界以外的内存
4. 分代算法：过呢据对象存活的周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代 采用标记整理算法。

#### JVM有哪些回收器

- Serial收集器（复制算法）：新生代单线程收集器，标记和清理都是单线程，简单高效

- ParNew收集器（复制算法）：新生代并行收集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现。

- Parallel Scavenge（复制算法）：新生代并行收集器，追求吞吐量，高效利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互响应要求不高的场景。

- SerialOld收集器（标记-整理算法）：老年代单线程收集器，Serial收集器老年代版本

- ParallelOld收集器：老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本

- CMS（Concurrent Mark Sweep）收集器（标记-清除算法）：老年代并行收集器，以获取最短回收停顿时间为目标的收集器具有高并发、低停顿的特点，追求最短GC回收停顿时间。
  
  **CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得  最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。 CMS 使用的是标记-清除的算法实现的，所以在 gc的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。**

- G1（Garbage First）收集器（标记-整理算法）：Java堆并行收集器，不会产生内存碎片，G1回收的是整个Java堆（包括新生代和老年代），而前六种收集器回收的范围 仅限于新生代和老年代。

#### 分代回收器是如何工作的

> 分代回收器有两个分区：老年代和新生代，新生代默认的空间占比总空间的1/3，老年代的默认占比是2/3;
> 
> 年轻代（New）：年轻代用来存放JVM刚分配的Java对象
> 年老代（Tenured)：年轻代中经过垃圾回收没有回收掉的对象将被Copy到年老代
> 永久代（Perm）：永久代存放Class、Method元信息，其大小跟项目的规模、类、方法的量有 
> 关，一般设置为128M就足够，设置原则是预留30%的空间。
> 
> 新生代使用的是复制算法，新生代里有三个分区：Eden、To  Survivor、From Survivor，他们的默认占比是8：1：1

- 把Eden和From Survivor活着的对象复制到 To Survivor
- 清空  Eden和From Survivor分区
- From Survivor 和 To Survivor分区交换，From  Survivor 变 To Survivor，To Survivor变 From Survivor

每次From  Survivor 到 To Survivor移动时都存活的对象，年龄+1，当年龄到达15时，升级为老年代。

大对象直接进入老年代。

### Java内存分配

#### 对象优先在Eden区进行分配

多数情况，对象都在新生代 Eden 区分配。当 Eden 区分配没有足够的空间进行 分配时，虚拟机将会发 
起一次 Minor GC。如果本次 GC后还是没有足够的空 间，则将启用分配担保机制在老年代中分配内存。
这里我们提到 Minor GC，如果你仔细观察过 GC 日常，通常我们还能从日志中  发现 Major GC/Full 
GC。
Minor GC 是指发生在新生代的 GC，因为 Java 对象大多都是朝生夕死，所  有 Minor GC 非常频 
繁，一般回收速度也非常快；Major GC/Full GC 是指发生在老年代的 GC，出现了 Major GC 通常会伴  随至少一次 Minor GC。 
Major GC 的速度通常会比 Minor GC 慢 10 倍以上。
大对象直接进入老年代
所谓大对象是指需要大量连续内存空间的对象，频繁出现大对象是致命的，会导  致在内存还有不少空间 
的情况下提前触发 GC 以获取足够的连续空间来安置新对  象。
前面我们介绍过新生代使用的是标记-清除算法来处理垃圾回收的，如果大对象 直接在新生代分配就会导 
致 Eden 区和两个 Survivor 区之间发生大量的内存复制。因此对于大对象都会直接在老年代进行分配。
长期存活对象将进入老年代
虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应 该放在新生代，哪些对 
象应该放在老年代。因此虚拟机给每个对象定义了一个对 象年龄的计数器，如果对象在 Eden 区出生， 
并且能够被 Survivor 容纳，将被 移动到 Survivor 空间中，这时设置对象年龄为 1。对象在 Survivor 区 
中每「熬 过」一次 Minor GC 年龄就加 1，当年龄达到一定程度（默认 15） 就会被晋升 到老年代。

#### 常用的 JVM 调优的参数都有哪些？

- -Xms2g：初始化推大小为 2g； 
- -Xmx2g：堆最大内存为 2g；
- -XX:newSize；-XX:MaxNewSize设置绝对大小
- -XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4； 
- -XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2； 
- –XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器 组合； 
- -XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；
- -XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合； 
- -XX:+PrintGC：开启打印 gc 信息；
- -XX:+PrintGCDetails：打印 gc 详细信息。

#### JVM调优

1. 多数的Java应用不需要在服务器上进行GC优化
2. 多数导致GC问题的Java应用，都不是因为我们参数设置错误，而是代码问题
3. 在应用上线之前，先考虑将机器的JVM参数设置到最优
4. 减少创建对象的数量
5. 减少使用全局变量和大对象
6. GC优化是到最后不得已才采用的手段
7. 在实际使用中，分析GC情况优化代码比优化GC参数要多得多。

#### GC优化目的：

1. 将转移到老年代的对象数量降低到最小
2. 减少Full GC 的执行时间。

##### 为了达到上面目的，一般地，你需要做的事情有

- 减少使用全局变量和大对象 
- 调整新生代的大小到合适
- 设置老年代的大小最为合适
- 选择合适的收集器。

##### JVM参数调优：

1. 针对JVM堆的设置，一般可以通过 `-Xms -Xmx`限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆产生的额外时间，我们通常把最大、最小设置为相同的值。

2. 年轻代和年老代根据默认的比例（1：2）分配堆内存，可以通过调整二者之间的比率`NewRatio`来调整二者之间大的大小，也可以针对回收代，比如年轻代通过`-XX:newSize  -XX:MaxNewSize`来设置新生代的最小最大值。同样，为了防止年轻代的堆收缩，我们通常会把`-XX:newSize -XX:MaxNewSize`设置为同样的大小。

3. 如何设置年轻代和年老代的大小？

   - ```markdown
      - 更大的年轻代 必然导致 更小的年老代，大的年轻代会延长普通GC的周期，但会增加每次GC的时间；小的年老代会导致更频繁的Full GC.
      - 更小的年轻代必然导致更大的年老代，小的年轻代会导致普通GC很频繁，但每次的GC时间会更短；大的老年代会减少Full GC的频率。
     ```

   - 本着Full GC尽量少的原则，让老年代尽量缓存常用对象，JVM的默认比例 1：2也是这个道理

   - 通过观察 应用一段时间，阿奎那其他在峰值的年老代会占用多少内存，在不影响Full GC的前提下，根据实际情况增加年轻代 
