## Alibaba-Sentinel

#### 服务雪崩问题：

当一个服务请求另外一个服务的时候，没有及时得到响应，阻塞线程请求，如果许多服务又请求这个服务的时候，则会占满线程池，导致当前的服务不可用，如果是微服务架构，则会导致整体微服务链路大面积失效，成为雪崩效果。

#### 解决雪崩问题：

1. 超时处理：设定超时时间，请求超过一定时间没有响应就返回错误信息，不会无休止等待**治标不治本**
2. 舱壁模式：限定每个业务能使用的线程数，避免耗尽整个tomcat的资源，也叫线程隔离**容易引起资源浪费**
3. 熔断降级：由断路器统计业务执行的异常比例，如果超出阈值则会熔断该业务，拦截访问该业务的一切请求。
4. 流量控制：限制业务访问的QPS，避免服务因流量的突增而故障。

#### 流控模式

1. 直接：统计当前资源的请求，触发阈值时对当前资源进行直接限流，也是默认的模式

2. 关联：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流。（/read资源与/write资源进行关联，会监听/write资源的使用状态，当关联资源/write触发阈值时，对统计资源/read进行限流。）
   
   **适用：**
   
   - 两个有竞争关系的资源
   
   - 一个优先级较高，一个优先级较低。

3. 链路：统计从指定链路访问到本资源的请求，触发阈值时，对指定链路限流。

#### 流控效果

1. 快速失败：当超过设定阈值，则直接抛出异常

2. Warmup：根据最大阈值/3，计算出流量最初时期的QPS阈值，后面逐渐增大阈值直到最大设定阈值。

3. 排队等待：是让所有请求进入一个队列中，然后按照阈值允许的时间间隔一次执行。后来的请求必须等待前面执行完成，如果请求预期的等待时间超出最大时长，则会拒绝抛出异常。

#### 热点参数限流

分别统计**参数值相同**的请求，判断是否超过QPS阈值。

#### 线程池隔离：

1. 基于信号量：轻量化，无额外开销

2. 基于线程池：可以自主独立控制响应时长，支持异步调用。但是额外开销较大

#### 熔断降级

熔断降级时解决雪崩问题的重要手段你。其思路时由**断路器**统计服务调用的比例、慢请求比例，如果超出阈值则会熔断该服务。即拦截访问该服务的一切请求；而当服务恢复时，断路器会放行访问该服务的请求。

```plantuml
hide footbox
title 熔断降级
Closed-> Open: 达到失败阈值
Closed--> Closed: success
Open --> Open: 快速失败
Open --> "Half-Open": 熔断时间结束
"Half-Open" -> "Half-Open": 尝试放行一次请求
"Half-Open" --> Open: fail打开断路器
"Half-Open" ---> Closed: 关闭断路器success
```

#### 限流算法

1. 固定窗口算法：
   * 将时间划分为多个窗口，窗口时间跨度为Interval
   * 每个窗口维护一个计数器，每有一次请求就将计数器加一，限流就是设置计数器阈值 
   * 如果计数器超过限流阈值，则超出阈值的请求都被丢弃
2. 滑动窗口计数算法：
   * 窗口时间跨度Interval为1秒；区间数量n=2，则每个小区间时间跨度为500ms
   * 限流阈值依然为3，时间窗口（1）秒内请求超过阈值时，超出的请求被限流
   * 窗口会根据当前请求所在时间（currentTime）移动，窗口范围从(currentTime - Interval)之后的第一个时区开始，到currentTime所在时区结束。
3. 令牌桶算法：
   * 以固定的速率生成令牌，存入令牌桶中，如果令牌桶满了以后，多余令牌将被丢弃
   * 请求进入后，必须先尝试从桶中获取令牌，获取到令牌后才可以被处理。
   * 如果令牌桶中没有令牌，则请求等待或者丢弃
4. 漏桶算法：
   * 将每个请求视作“水滴”放入“漏桶”进行存储
   * “漏桶”以固定速率向外“漏出”请求来执行，如果“漏桶”空了则停止漏水。
   * 如果“漏桶”满了则多余 的“水滴”会被直接丢弃

| 对比项               | 滑动时间窗口                               | 令牌桶                                                       | 漏桶                                           |
| -------------------- | ------------------------------------------ | ------------------------------------------------------------ | ---------------------------------------------- |
| 能否保证流量曲线平滑 | 不能，但窗口区间越小，流量控制越平滑       | 基本能，在请求量持续高于令牌生成速度时，流量平滑，但请求在令牌生成速率上下波动时，无法保证曲线平滑 | 能，所有请求进入桶内，以恒定速率放行，绝对平滑 |
| 能否应对突增流量     | 不能，突增流量，只要高出限流阈值都会被拒绝 | 能，桶内积累的令牌可以应对突增流量                           | 能，请求可以暂存在桶内                         |
| 流量控制精确度       | 低，窗口区间越小 ，精度越高                | 高                                                           | 高                                             |

#### Sentinel的线程隔离与Hystrix的线程隔离有什么差别

Hystrix默认是基于线程池实现线程隔离，每一个被隔离的业务都要创建一个独立的线程池，线程池多会带来额外的CPU开销，性能一般，但是隔离性更强。

Sentinel是基于信号量（计数器）实现的线程隔离，不用创建线程池，性能较好，但是隔离性一般。

#### Sentinel的限流与Gateway的限流有什么差别

限流算法常见的有三张实现：滑动时间窗口、令牌桶算法（Token Bucket）、漏桶算法。Gateway则采用了基于Redis实现 的令牌桶算法。而Sentinel内部却比较复杂：

- 默认限流模式是基于滑动时间窗口算法
- 排队等待的限流模式基于漏桶算法
- 热点参数限流是 基于令牌桶算法
