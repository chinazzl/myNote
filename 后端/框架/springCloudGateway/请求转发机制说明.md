# Spring Cloud Gateway 请求转发机制详解

Spring Cloud Gateway 的请求转发是一个精心设计的过程，我来详细解释其工作原理。

## 核心流程概览

```
客户端请求 → Gateway Handler Mapping → Web Handler → Filter Chain → Route → Load Balancer → 目标服务
```

## 详细工作流程

### 1. 请求接收和路由匹配

当请求到达 Gateway 时，首先经过 **RoutePredicateHandlerMapping**：

```java
// Spring Cloud Gateway 核心处理类
public class RoutePredicateHandlerMapping extends AbstractHandlerMapping {
    
    @Override
    protected Mono<?> getHandlerInternal(ServerWebExchange exchange) {
        // 设置网关路由属性
        exchange.getAttributes().put(GATEWAY_HANDLER_MAPPER_ATTR, getSimpleName());

        // 查找匹配的路由
        return lookupRoute(exchange)
            .flatMap((Function<Route, Mono<?>>) r -> {
                // 移除不必要的属性
                exchange.getAttributes().remove(GATEWAY_PREDICATE_ROUTE_ATTR);
                // 将匹配的路由放入exchange
                exchange.getAttributes().put(GATEWAY_ROUTE_ATTR, r);
                return Mono.just(webHandler);
            })
            .switchIfEmpty(Mono.empty().then(Mono.fromRunnable(() -> {
                // 没有找到路由
                exchange.getResponse().setStatusCode(HttpStatus.NOT_FOUND);
            })));
    }

    protected Mono<Route> lookupRoute(ServerWebExchange exchange) {
        // 遍历所有路由，找到第一个匹配的
        return this.routeLocator.getRoutes()
            .concatMap(route -> Mono.just(route)
                .filterWhen(r -> {
                    // 使用 Predicate 判断是否匹配
                    exchange.getAttributes().put(GATEWAY_PREDICATE_ROUTE_ATTR, r.getId());
                    return r.getPredicate().apply(exchange);
                })
                .doOnError(e -> logger.error("Error applying predicate for route: " + route.getId(), e))
                .onErrorResume(e -> Mono.empty())
            )
            .next(); // 返回第一个匹配的路由
    }
}
```

### 2. 过滤器链处理

找到路由后，请求会经过 **FilteringWebHandler**，这是过滤器链的核心：

```java
public class FilteringWebHandler implements WebHandler {
    
    private final List<GatewayFilter> globalFilters;

    @Override
    public Mono<Void> handle(ServerWebExchange exchange) {
        Route route = exchange.getRequiredAttribute(GATEWAY_ROUTE_ATTR);
        
        // 获取当前路由的过滤器
        List<GatewayFilter> gatewayFilters = route.getFilters();

        // 合并全局过滤器和路由过滤器
        List<GatewayFilter> combined = new ArrayList<>(this.globalFilters);
        combined.addAll(gatewayFilters);
        
        // 排序过滤器
        AnnotationAwareOrderComparator.sort(combined);

        // 构建过滤器链并执行
        return new DefaultGatewayFilterChain(combined).filter(exchange);
    }
}
```

### 3. 路由定位过滤器（核心转发逻辑）

**RouteToRequestUrlFilter** 负责构建目标服务的 URL：

```java
public class RouteToRequestUrlFilter implements GlobalFilter, Ordered {

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        Route route = exchange.getAttribute(GATEWAY_ROUTE_ATTR);
        if (route == null) {
            return chain.filter(exchange);
        }
        
        URI uri = exchange.getRequest().getURI();
        boolean encoded = containsEncodedParts(uri);
        
        // 获取路由配置的目标 URI
        URI routeUri = route.getUri();

        // 如果是 lb:// 协议（负载均衡）
        if (hasAnotherScheme(routeUri)) {
            // 保留 lb://service-name 这样的 URI
            exchange.getAttributes().put(GATEWAY_SCHEME_PREFIX_ATTR, routeUri.getScheme());
            routeUri = URI.create(routeUri.getSchemeSpecificPart());
        }

        // 合并路径，构建完整的请求 URL
        URI mergedUrl = UriComponentsBuilder.fromUri(uri)
            .scheme(routeUri.getScheme())
            .host(routeUri.getHost())
            .port(routeUri.getPort())
            .build(encoded)
            .toUri();
        
        // 将目标 URL 放入 exchange
        exchange.getAttributes().put(GATEWAY_REQUEST_URL_ATTR, mergedUrl);
        
        return chain.filter(exchange);
    }
}
```

### 4. 负载均衡处理

**ReactorLoadBalancerClientFilter** 处理服务发现和负载均衡：

```java
public class ReactorLoadBalancerClientFilter implements GlobalFilter, Ordered {

    private final LoadBalancerClientFactory clientFactory;

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        URI url = exchange.getAttribute(GATEWAY_REQUEST_URL_ATTR);
        String schemePrefix = exchange.getAttribute(GATEWAY_SCHEME_PREFIX_ATTR);
        
        // 只处理 lb:// 协议的请求
        if (url == null || (!"lb".equals(url.getScheme()) && !"lb".equals(schemePrefix))) {
            return chain.filter(exchange);
        }

        // 获取服务名称
        String serviceId = url.getHost();
        
        // 获取负载均衡器
        ReactorLoadBalancer<ServiceInstance> loadBalancer = 
            this.clientFactory.getInstance(serviceId, ReactorServiceInstanceLoadBalancer.class);

        if (loadBalancer == null) {
            throw new NotFoundException("No loadbalancer available for " + serviceId);
        }

        // 选择一个服务实例
        return choose(loadBalancer, exchange)
            .doOnNext(response -> {
                if (!response.hasServer()) {
                    throw new NotFoundException("Unable to find instance for " + serviceId);
                }

                ServiceInstance instance = response.getServer();
                
                // 构建实际的服务 URL
                URI uri = exchange.getRequest().getURI();
                String overrideScheme = instance.isSecure() ? "https" : "http";
                
                URI requestUrl = UriComponentsBuilder.fromUri(uri)
                    .scheme(overrideScheme)
                    .host(instance.getHost())
                    .port(instance.getPort())
                    .build(true)
                    .toUri();

                // 更新目标 URL
                exchange.getAttributes().put(GATEWAY_REQUEST_URL_ATTR, requestUrl);
            })
            .then(chain.filter(exchange));
    }

    private Mono<Response<ServiceInstance>> choose(
            ReactorLoadBalancer<ServiceInstance> loadBalancer,
            ServerWebExchange exchange) {
        // 执行负载均衡选择
        return loadBalancer.choose(createRequest(exchange));
    }
}
```

### 5. 实际发送 HTTP 请求

**NettyRoutingFilter** 或 **WebClientHttpRoutingFilter** 负责实际发送请求：

```java
public class NettyRoutingFilter implements GlobalFilter, Ordered {

    private final HttpClient httpClient;

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        URI requestUrl = exchange.getRequiredAttribute(GATEWAY_REQUEST_URL_ATTR);

        String scheme = requestUrl.getScheme();
        // 只处理 http 和 https
        if (isAlreadyRouted(exchange) || 
            (!scheme.equals("http") && !scheme.equals("https"))) {
            return chain.filter(exchange);
        }

        // 标记已经路由
        setAlreadyRouted(exchange);

        ServerHttpRequest request = exchange.getRequest();

        // 获取 HTTP 方法
        HttpMethod method = HttpMethod.valueOf(request.getMethodValue());

        // 构建请求
        return this.httpClient
            .request(method)
            .uri(requestUrl.toString())
            .send((req, nettyOutbound) -> {
                // 设置请求头
                req.headers().set(request.getHeaders());
                
                // 发送请求体
                return nettyOutbound.send(request.getBody()
                    .map(dataBuffer -> {
                        return nettyOutbound.alloc().wrap(dataBuffer.asByteBuffer());
                    }));
            })
            .responseConnection((res, conn) -> {
                // 处理响应
                ServerHttpResponse response = exchange.getResponse();
                
                // 设置响应状态码
                response.setStatusCode(HttpStatus.valueOf(res.status().code()));
                
                // 设置响应头
                res.responseHeaders().entries().forEach(entry -> 
                    response.getHeaders().add(entry.getKey(), entry.getValue())
                );

                // 写入响应体
                return response.writeWith(conn.inbound().receive()
                    .retain()
                    .map(byteBuf -> {
                        return response.bufferFactory().wrap(byteBuf.nioBuffer());
                    }));
            })
            .then();
    }
}
```

## 配置示例

### 静态路由配置

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: http://localhost:8081  # 直接指定 URL
          predicates:
            - Path=/api/user/**
          filters:
            - StripPrefix=1

        - id: order-service
          uri: lb://order-service  # 使用负载均衡
          predicates:
            - Path=/api/order/**
          filters:
            - StripPrefix=1
```

### 动态路由配置（编程方式）

```java
@Configuration
public class GatewayRouteConfig {

    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        return builder.routes()
            .route("user-service", r -> r
                .path("/api/user/**")
                .filters(f -> f
                    .stripPrefix(1)
                    .addRequestHeader("X-Gateway", "Spring-Cloud-Gateway")
                )
                .uri("lb://user-service")
            )
            .route("order-service", r -> r
                .path("/api/order/**")
                .filters(f -> f.stripPrefix(1))
                .uri("lb://order-service")
            )
            .build();
    }
}
```

## 关键组件总结

| 组件 | 职责 |
|------|------|
| RoutePredicateHandlerMapping | 路由匹配，找到符合条件的路由 |
| FilteringWebHandler | 组织和执行过滤器链 |
| RouteToRequestUrlFilter | 构建目标服务 URL |
| ReactorLoadBalancerClientFilter | 服务发现和负载均衡 |
| NettyRoutingFilter | 使用 Netty 发送 HTTP 请求 |
| NettyWriteResponseFilter | 将响应写回客户端 |

## 请求转发的三种方式

1. **直接 URL 转发**：`uri: http://localhost:8081`
2. **负载均衡转发**：`uri: lb://service-name`（需要配合 Nacos/Eureka 等注册中心）
3. **WebSocket 转发**：`uri: ws://localhost:8081`

整个过程基于 **Spring WebFlux** 的响应式编程模型，所有操作都是非阻塞的，能够高效处理大量并发请求。

你的项目是想了解哪个具体环节？或者遇到了什么问题？