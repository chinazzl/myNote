# 第三方接口数据同步完整模板

## 1. 项目结构
```
src/main/java/com/example/sync/
├── config/
│   ├── AsyncConfig.java
│   ├── RestTemplateConfig.java
│   └── ScheduleConfig.java
├── constant/
│   └── SyncConstants.java
├── dto/
│   ├── ThirdPartyUserDto.java
│   └── SyncResultDto.java
├── entity/
│   ├── SyncLog.java
│   └── User.java
├── enums/
│   └── SyncStatusEnum.java
├── exception/
│   └── SyncException.java
├── mapper/
│   ├── SyncLogMapper.java
│   └── UserMapper.java
├── service/
│   ├── ThirdPartyApiService.java
│   ├── SyncService.java
│   └── impl/
│       ├── ThirdPartyApiServiceImpl.java
│       └── SyncServiceImpl.java
├── task/
│   └── SyncTask.java
└── util/
    ├── RetryUtil.java
    └── CircuitBreakerUtil.java
```

## 2. 依赖配置 (pom.xml)
```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-jdbc</artifactId>
    </dependency>
    <dependency>
        <groupId>org.mybatis.spring.boot</groupId>
        <artifactId>mybatis-spring-boot-starter</artifactId>
        <version>2.2.2</version>
    </dependency>
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.retry</groupId>
        <artifactId>spring-retry</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-aspects</artifactId>
    </dependency>
    <dependency>
        <groupId>com.github.rholder</groupId>
        <artifactId>guava-retrying</artifactId>
        <version>2.0.0</version>
    </dependency>
    <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-lang3</artifactId>
    </dependency>
</dependencies>
```

## 3. 配置文件 (application.yml)
```yaml
server:
  port: 8080

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/sync_db?useUnicode=true&characterEncoding=utf8&serverTimezone=GMT%2B8
    username: root
    password: password
    driver-class-name: com.mysql.cj.jdbc.Driver
  
  task:
    scheduling:
      pool:
        size: 5
    execution:
      pool:
        core-size: 10
        max-size: 20
        queue-capacity: 100

mybatis:
  mapper-locations: classpath:mapper/*.xml
  type-aliases-package: com.example.sync.entity
  configuration:
    map-underscore-to-camel-case: true

# 第三方接口配置
third-party:
  api:
    base-url: https://api.third-party.com
    timeout: 30000
    retry-count: 3
    api-key: your-api-key
    secret: your-secret

# 同步配置
sync:
  batch-size: 100
  cron: "0 */10 * * * ?"  # 每10分钟执行一次
  enabled: true
```

## 4. 实体类
```java
// User.java
package com.example.sync.entity;

import java.time.LocalDateTime;

public class User {
    private Long id;
    private String thirdPartyId;
    private String username;
    private String email;
    private String phone;
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
    private Integer version;
    
    // getters and setters...
}

// SyncLog.java
package com.example.sync.entity;

import java.time.LocalDateTime;

public class SyncLog {
    private Long id;
    private String syncType;
    private String status;
    private Integer totalCount;
    private Integer successCount;
    private Integer failCount;
    private String errorMessage;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private String batchId;
    
    // getters and setters...
}
```

## 5. DTO类
```java
// ThirdPartyUserDto.java
package com.example.sync.dto;

import com.fasterxml.jackson.annotation.JsonProperty;

public class ThirdPartyUserDto {
    @JsonProperty("user_id")
    private String userId;
    
    @JsonProperty("user_name")
    private String userName;
    
    private String email;
    private String phone;
    
    @JsonProperty("created_at")
    private String createdAt;
    
    @JsonProperty("updated_at")
    private String updatedAt;
    
    // getters and setters...
}

// SyncResultDto.java
package com.example.sync.dto;

public class SyncResultDto {
    private boolean success;
    private int totalCount;
    private int successCount;
    private int failCount;
    private String message;
    
    // constructors, getters and setters...
}
```

## 6. 枚举类
```java
// SyncStatusEnum.java
package com.example.sync.enums;

public enum SyncStatusEnum {
    RUNNING("RUNNING", "同步中"),
    SUCCESS("SUCCESS", "成功"),
    FAILED("FAILED", "失败"),
    PARTIAL_SUCCESS("PARTIAL_SUCCESS", "部分成功");
    
    private final String code;
    private final String desc;
    
    SyncStatusEnum(String code, String desc) {
        this.code = code;
        this.desc = desc;
    }
    
    // getters...
}
```

## 7. 配置类
```java
// RestTemplateConfig.java
package com.example.sync.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.SimpleClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;

@Configuration
public class RestTemplateConfig {
    
    @Value("${third-party.api.timeout:30000}")
    private int timeout;
    
    @Bean
    public RestTemplate restTemplate() {
        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();
        factory.setConnectTimeout(timeout);
        factory.setReadTimeout(timeout);
        return new RestTemplate(factory);
    }
}

// AsyncConfig.java
package com.example.sync.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableAsync;

@Configuration
@EnableAsync
public class AsyncConfig {
    // 可以自定义线程池
}

// ScheduleConfig.java
package com.example.sync.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableScheduling;

@Configuration
@EnableScheduling
public class ScheduleConfig {
}
```

## 8. 第三方API服务
```java
// ThirdPartyApiService.java
package com.example.sync.service;

import com.example.sync.dto.ThirdPartyUserDto;
import java.util.List;

public interface ThirdPartyApiService {
    List<ThirdPartyUserDto> fetchUsers(int page, int size);
    List<ThirdPartyUserDto> fetchUsersByTimestamp(long timestamp, int page, int size);
}

// ThirdPartyApiServiceImpl.java
package com.example.sync.service.impl;

import com.example.sync.dto.ThirdPartyUserDto;
import com.example.sync.exception.SyncException;
import com.example.sync.service.ThirdPartyApiService;
import com.example.sync.util.RetryUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import javax.annotation.Resource;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

@Service
public class ThirdPartyApiServiceImpl implements ThirdPartyApiService {
    
    private static final Logger logger = LoggerFactory.getLogger(ThirdPartyApiServiceImpl.class);
    
    @Resource
    private RestTemplate restTemplate;
    
    @Value("${third-party.api.base-url}")
    private String baseUrl;
    
    @Value("${third-party.api.api-key}")
    private String apiKey;
    
    @Override
    public List<ThirdPartyUserDto> fetchUsers(int page, int size) {
        return RetryUtil.executeWithRetry(() -> {
            String url = baseUrl + "/users?page=" + page + "&size=" + size;
            HttpHeaders headers = createHeaders();
            HttpEntity<?> entity = new HttpEntity<>(headers);
            
            try {
                ResponseEntity<ThirdPartyUserDto[]> response = 
                    restTemplate.exchange(url, HttpMethod.GET, entity, ThirdPartyUserDto[].class);
                
                if (response.getStatusCode() == HttpStatus.OK && response.getBody() != null) {
                    return Arrays.asList(response.getBody());
                }
                throw new SyncException("获取用户数据失败: " + response.getStatusCode());
            } catch (Exception e) {
                logger.error("调用第三方接口失败: {}", e.getMessage());
                throw new SyncException("调用第三方接口失败", e);
            }
        });
    }
    
    @Override
    public List<ThirdPartyUserDto> fetchUsersByTimestamp(long timestamp, int page, int size) {
        return RetryUtil.executeWithRetry(() -> {
            String url = String.format("%s/users?timestamp=%d&page=%d&size=%d", 
                baseUrl, timestamp, page, size);
            HttpHeaders headers = createHeaders();
            HttpEntity<?> entity = new HttpEntity<>(headers);
            
            try {
                ResponseEntity<ThirdPartyUserDto[]> response = 
                    restTemplate.exchange(url, HttpMethod.GET, entity, ThirdPartyUserDto[].class);
                
                if (response.getStatusCode() == HttpStatus.OK && response.getBody() != null) {
                    return Arrays.asList(response.getBody());
                }
                throw new SyncException("获取增量用户数据失败: " + response.getStatusCode());
            } catch (Exception e) {
                logger.error("调用第三方接口失败: {}", e.getMessage());
                throw new SyncException("调用第三方接口失败", e);
            }
        });
    }
    
    private HttpHeaders createHeaders() {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("Authorization", "Bearer " + apiKey);
        headers.set("User-Agent", "SyncService/1.0");
        return headers;
    }
}
```

## 9. 同步服务
```java
// SyncService.java
package com.example.sync.service;

import com.example.sync.dto.SyncResultDto;

public interface SyncService {
    SyncResultDto syncAllUsers();
    SyncResultDto syncIncrementalUsers();
    void asyncSyncAllUsers();
}

// SyncServiceImpl.java
package com.example.sync.service.impl;

import com.example.sync.dto.SyncResultDto;
import com.example.sync.dto.ThirdPartyUserDto;
import com.example.sync.entity.SyncLog;
import com.example.sync.entity.User;
import com.example.sync.enums.SyncStatusEnum;
import com.example.sync.mapper.SyncLogMapper;
import com.example.sync.mapper.UserMapper;
import com.example.sync.service.SyncService;
import com.example.sync.service.ThirdPartyApiService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;
import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
public class SyncServiceImpl implements SyncService {
    
    private static final Logger logger = LoggerFactory.getLogger(SyncServiceImpl.class);
    
    @Resource
    private ThirdPartyApiService thirdPartyApiService;
    
    @Resource
    private UserMapper userMapper;
    
    @Resource
    private SyncLogMapper syncLogMapper;
    
    @Value("${sync.batch-size:100}")
    private int batchSize;
    
    @Override
    @Transactional
    public SyncResultDto syncAllUsers() {
        String batchId = UUID.randomUUID().toString();
        SyncLog syncLog = createSyncLog("FULL_SYNC", batchId);
        
        try {
            int page = 1;
            int totalSuccess = 0;
            int totalFail = 0;
            int totalCount = 0;
            
            while (true) {
                List<ThirdPartyUserDto> users = thirdPartyApiService.fetchUsers(page, batchSize);
                if (users.isEmpty()) {
                    break;
                }
                
                totalCount += users.size();
                
                for (ThirdPartyUserDto userDto : users) {
                    try {
                        User user = convertToUser(userDto);
                        User existingUser = userMapper.findByThirdPartyId(user.getThirdPartyId());
                        
                        if (existingUser != null) {
                            user.setId(existingUser.getId());
                            user.setVersion(existingUser.getVersion());
                            userMapper.updateByThirdPartyId(user);
                        } else {
                            userMapper.insert(user);
                        }
                        totalSuccess++;
                    } catch (Exception e) {
                        logger.error("同步用户失败: {}, 错误: {}", userDto.getUserId(), e.getMessage());
                        totalFail++;
                    }
                }
                page++;
            }
            
            // 更新同步日志
            updateSyncLog(syncLog, SyncStatusEnum.SUCCESS, totalCount, totalSuccess, totalFail, null);
            return new SyncResultDto(true, totalCount, totalSuccess, totalFail, "同步完成");
            
        } catch (Exception e) {
            logger.error("全量同步失败: {}", e.getMessage(), e);
            updateSyncLog(syncLog, SyncStatusEnum.FAILED, 0, 0, 0, e.getMessage());
            return new SyncResultDto(false, 0, 0, 0, "同步失败: " + e.getMessage());
        }
    }
    
    @Override
    @Transactional
    public SyncResultDto syncIncrementalUsers() {
        String batchId = UUID.randomUUID().toString();
        SyncLog syncLog = createSyncLog("INCREMENTAL_SYNC", batchId);
        
        try {
            // 获取最后同步时间
            SyncLog lastSync = syncLogMapper.findLastSuccessSync("INCREMENTAL_SYNC");
            long timestamp = lastSync != null ? 
                lastSync.getStartTime().atZone(java.time.ZoneId.systemDefault()).toEpochSecond() * 1000 :
                System.currentTimeMillis() - 24 * 60 * 60 * 1000; // 默认取24小时前
                
            int page = 1;
            int totalSuccess = 0;
            int totalFail = 0;
            int totalCount = 0;
            
            while (true) {
                List<ThirdPartyUserDto> users = thirdPartyApiService.fetchUsersByTimestamp(timestamp, page, batchSize);
                if (users.isEmpty()) {
                    break;
                }
                
                totalCount += users.size();
                
                for (ThirdPartyUserDto userDto : users) {
                    try {
                        User user = convertToUser(userDto);
                        User existingUser = userMapper.findByThirdPartyId(user.getThirdPartyId());
                        
                        if (existingUser != null) {
                            user.setId(existingUser.getId());
                            user.setVersion(existingUser.getVersion());
                            userMapper.updateByThirdPartyId(user);
                        } else {
                            userMapper.insert(user);
                        }
                        totalSuccess++;
                    } catch (Exception e) {
                        logger.error("同步用户失败: {}, 错误: {}", userDto.getUserId(), e.getMessage());
                        totalFail++;
                    }
                }
                page++;
            }
            
            updateSyncLog(syncLog, SyncStatusEnum.SUCCESS, totalCount, totalSuccess, totalFail, null);
            return new SyncResultDto(true, totalCount, totalSuccess, totalFail, "增量同步完成");
            
        } catch (Exception e) {
            logger.error("增量同步失败: {}", e.getMessage(), e);
            updateSyncLog(syncLog, SyncStatusEnum.FAILED, 0, 0, 0, e.getMessage());
            return new SyncResultDto(false, 0, 0, 0, "增量同步失败: " + e.getMessage());
        }
    }
    
    @Override
    @Async
    public void asyncSyncAllUsers() {
        logger.info("开始异步全量同步");
        syncAllUsers();
        logger.info("异步全量同步完成");
    }
    
    private User convertToUser(ThirdPartyUserDto dto) {
        User user = new User();
        user.setThirdPartyId(dto.getUserId());
        user.setUsername(dto.getUserName());
        user.setEmail(dto.getEmail());
        user.setPhone(dto.getPhone());
        user.setUpdateTime(LocalDateTime.now());
        if (user.getCreateTime() == null) {
            user.setCreateTime(LocalDateTime.now());
        }
        return user;
    }
    
    private SyncLog createSyncLog(String syncType, String batchId) {
        SyncLog syncLog = new SyncLog();
        syncLog.setSyncType(syncType);
        syncLog.setStatus(SyncStatusEnum.RUNNING.getCode());
        syncLog.setStartTime(LocalDateTime.now());
        syncLog.setBatchId(batchId);
        syncLogMapper.insert(syncLog);
        return syncLog;
    }
    
    private void updateSyncLog(SyncLog syncLog, SyncStatusEnum status, 
                              int totalCount, int successCount, int failCount, String errorMessage) {
        syncLog.setStatus(status.getCode());
        syncLog.setTotalCount(totalCount);
        syncLog.setSuccessCount(successCount);
        syncLog.setFailCount(failCount);
        syncLog.setErrorMessage(errorMessage);
        syncLog.setEndTime(LocalDateTime.now());
        syncLogMapper.updateById(syncLog);
    }
}
```

## 10. 定时任务
```java
// SyncTask.java
package com.example.sync.task;

import com.example.sync.service.SyncService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;

@Component
@ConditionalOnProperty(name = "sync.enabled", havingValue = "true", matchIfMissing = false)
public class SyncTask {
    
    private static final Logger logger = LoggerFactory.getLogger(SyncTask.class);
    
    @Resource
    private SyncService syncService;
    
    @Scheduled(cron = "${sync.cron}")
    public void incrementalSync() {
        logger.info("开始执行定时增量同步任务");
        try {
            syncService.syncIncrementalUsers();
            logger.info("定时增量同步任务完成");
        } catch (Exception e) {
            logger.error("定时增量同步任务执行失败", e);
        }
    }
    
    // 每天凌晨2点执行全量同步
    @Scheduled(cron = "0 0 2 * * ?")
    public void fullSync() {
        logger.info("开始执行定时全量同步任务");
        try {
            syncService.asyncSyncAllUsers();
            logger.info("定时全量同步任务启动完成");
        } catch (Exception e) {
            logger.error("定时全量同步任务执行失败", e);
        }
    }
}
```

## 11. 工具类
```java
// RetryUtil.java
package com.example.sync.util;

import com.github.rholder.retry.*;
import com.google.common.base.Predicates;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.concurrent.Callable;
import java.util.concurrent.TimeUnit;

public class RetryUtil {
    
    private static final Logger logger = LoggerFactory.getLogger(RetryUtil.class);
    
    public static <T> T executeWithRetry(Callable<T> callable) {
        Retryer<T> retryer = RetryerBuilder.<T>newBuilder()
            .retryIfException()
            .retryIfRuntimeException()
            .retryIfResult(Predicates.isNull())
            .withStopStrategy(StopStrategies.stopAfterAttempt(3))
            .withWaitStrategy(WaitStrategies.exponentialWait(1000, 10000, TimeUnit.MILLISECONDS))
            .withRetryListener(new RetryListener() {
                @Override
                public <V> void onRetry(Attempt<V> attempt) {
                    if (attempt.hasException()) {
                        logger.warn("第{}次重试失败: {}", 
                            attempt.getAttemptNumber(), 
                            attempt.getExceptionCause().getMessage());
                    }
                }
            })
            .build();
            
        try {
            return retryer.call(callable);
        } catch (Exception e) {
            logger.error("重试执行失败", e);
            throw new RuntimeException("重试执行失败", e);
        }
    }
}
```

## 12. Mapper接口
```java
// UserMapper.java
package com.example.sync.mapper;

import com.example.sync.entity.User;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;

import java.util.List;

@Mapper
public interface UserMapper {
    int insert(User user);
    int updateByThirdPartyId(User user);
    User findByThirdPartyId(@Param("thirdPartyId") String thirdPartyId);
    List<User> findAll();
    int deleteByThirdPartyId(@Param("thirdPartyId") String thirdPartyId);
}

// SyncLogMapper.java
package com.example.sync.mapper;

import com.example.sync.entity.SyncLog;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;

import java.util.List;

@Mapper
public interface SyncLogMapper {
    int insert(SyncLog syncLog);
    int updateById(SyncLog syncLog);
    SyncLog findById(@Param("id") Long id);
    SyncLog findLastSuccessSync(@Param("syncType") String syncType);
    List<SyncLog> findByStatus(@Param("status") String status);
}
```

## 13. MyBatis XML映射文件
```xml
<!-- UserMapper.xml -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.example.sync.mapper.UserMapper">
    
    <resultMap id="BaseResultMap" type="com.example.sync.entity.User">
        <id column="id" jdbcType="BIGINT" property="id" />
        <result column="third_party_id" jdbcType="VARCHAR" property="thirdPartyId" />
        <result column="username" jdbcType="VARCHAR" property="username" />
        <result column="email" jdbcType="VARCHAR" property="email" />
        <result column="phone" jdbcType="VARCHAR" property="phone" />
        <result column="create_time" jdbcType="TIMESTAMP" property="createTime" />
        <result column="update_time" jdbcType="TIMESTAMP" property="updateTime" />
        <result column="version" jdbcType="INTEGER" property="version" />
    </resultMap>

    <insert id="insert" parameterType="com.example.sync.entity.User" useGeneratedKeys="true" keyProperty="id">
        INSERT INTO users (third_party_id, username, email, phone, create_time, update_time, version)
        VALUES (#{thirdPartyId}, #{username}, #{email}, #{phone}, #{createTime}, #{updateTime}, 1)
    </insert>

    <update id="updateByThirdPartyId" parameterType="com.example.sync.entity.User">
        UPDATE users 
        SET username = #{username},
            email = #{email},
            phone = #{phone},
            update_time = #{updateTime},
            version = version + 1
        WHERE third_party_id = #{thirdPartyId} AND version = #{version}
    </update>

    <select id="findByThirdPartyId" parameterType="java.lang.String" resultMap="BaseResultMap">
        SELECT * FROM users WHERE third_party_id = #{thirdPartyId}
    </select>

    <select id="findAll" resultMap="BaseResultMap">
        SELECT * FROM users ORDER BY create_time DESC
    </select>

    <delete id="deleteByThirdPartyId" parameterType="java.lang.String">
        DELETE FROM users WHERE third_party_id = #{thirdPartyId}
    </delete>

</mapper>

<!-- SyncLogMapper.xml -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.example.sync.mapper.SyncLogMapper">
    
    <resultMap id="BaseResultMap" type="com.example.sync.entity.SyncLog">
        <id column="id" jdbcType="BIGINT" property="id" />
        <result column="sync_type" jdbcType="VARCHAR" property="syncType" />
        <result column="status" jdbcType="VARCHAR" property="status" />
        <result column="total_count" jdbcType="INTEGER" property="totalCount" />
        <result column="success_count" jdbcType="INTEGER" property="successCount" />
        <result column="fail_count" jdbcType="INTEGER" property="failCount" />
        <result column="error_message" jdbcType="TEXT" property="errorMessage" />
        <result column="start_time" jdbcType="TIMESTAMP" property="startTime" />
        <result column="end_time" jdbcType="TIMESTAMP" property="endTime" />
        <result column="batch_id" jdbcType="VARCHAR" property="batchId" />
    </resultMap>

    <insert id="insert" parameterType="com.example.sync.entity.SyncLog" useGeneratedKeys="true" keyProperty="id">
        INSERT INTO sync_logs (sync_type, status, start_time, batch_id)
        VALUES (#{syncType}, #{status}, #{startTime}, #{batchId})
    </insert>

    <update id="updateById" parameterType="com.example.sync.entity.SyncLog">
        UPDATE sync_logs 
        SET status = #{status},
            total_count = #{totalCount},
            success_count = #{successCount},
            fail_count = #{failCount},
            error_message = #{errorMessage},
            end_time = #{endTime}
        WHERE id = #{id}
    </update>

    <select id="findById" parameterType="java.lang.Long" resultMap="BaseResultMap">
        SELECT * FROM sync_logs WHERE id = #{id}
    </select>

    <select id="findLastSuccessSync" parameterType="java.lang.String" resultMap="BaseResultMap">
        SELECT * FROM sync_logs 
        WHERE sync_type = #{syncType} AND status = 'SUCCESS'
        ORDER BY start_time DESC 
        LIMIT 1
    </select>

    <select id="findByStatus" parameterType="java.lang.String" resultMap="BaseResultMap">
        SELECT * FROM sync_logs WHERE status = #{status} ORDER BY start_time DESC
    </select>

</mapper>
```

## 14. 数据库表结构 (MySQL)
```sql
-- 用户表
CREATE TABLE users (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    third_party_id VARCHAR(100) NOT NULL UNIQUE COMMENT '第三方用户ID',
    username VARCHAR(100) COMMENT '用户名',
    email VARCHAR(200) COMMENT '邮箱',
    phone VARCHAR(20) COMMENT '手机号',
    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    version INT DEFAULT 1 COMMENT '版本号，用于乐观锁',
    INDEX idx_third_party_id (third_party_id),
    INDEX idx_update_time (update_time)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户表';

-- 同步日志表
CREATE TABLE sync_logs (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    sync_type VARCHAR(50) NOT NULL COMMENT '同步类型：FULL_SYNC/INCREMENTAL_SYNC',
    status VARCHAR(20) NOT NULL COMMENT '同步状态：RUNNING/SUCCESS/FAILED/PARTIAL_SUCCESS',
    total_count INT DEFAULT 0 COMMENT '总数量',
    success_count INT DEFAULT 0 COMMENT '成功数量',
    fail_count INT DEFAULT 0 COMMENT '失败数量',
    error_message TEXT COMMENT '错误信息',
    start_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '开始时间',
    end_time TIMESTAMP NULL COMMENT '结束时间',
    batch_id VARCHAR(100) COMMENT '批次ID',
    INDEX idx_sync_type (sync_type),
    INDEX idx_status (status),
    INDEX idx_start_time (start_time),
    INDEX idx_batch_id (batch_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='同步日志表';
```

## 15. 异常处理类
```java
// SyncException.java
package com.example.sync.exception;

public class SyncException extends RuntimeException {
    
    public SyncException(String message) {
        super(message);
    }
    
    public SyncException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

## 16. 控制器类
```java
// SyncController.java
package com.example.sync.controller;

import com.example.sync.dto.SyncResultDto;
import com.example.sync.entity.SyncLog;
import com.example.sync.mapper.SyncLogMapper;
import com.example.sync.service.SyncService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import javax.annotation.Resource;
import java.util.List;

@RestController
@RequestMapping("/api/sync")
public class SyncController {
    
    @Resource
    private SyncService syncService;
    
    @Resource
    private SyncLogMapper syncLogMapper;
    
    /**
     * 手动触发全量同步
     */
    @PostMapping("/full")
    public ResponseEntity<SyncResultDto> triggerFullSync() {
        SyncResultDto result = syncService.syncAllUsers();
        return ResponseEntity.ok(result);
    }
    
    /**
     * 手动触发增量同步
     */
    @PostMapping("/incremental")
    public ResponseEntity<SyncResultDto> triggerIncrementalSync() {
        SyncResultDto result = syncService.syncIncrementalUsers();
        return ResponseEntity.ok(result);
    }
    
    /**
     * 异步触发全量同步
     */
    @PostMapping("/full/async")
    public ResponseEntity<String> triggerAsyncFullSync() {
        syncService.asyncSyncAllUsers();
        return ResponseEntity.ok("异步全量同步已启动");
    }
    
    /**
     * 查询同步日志
     */
    @GetMapping("/logs")
    public ResponseEntity<List<SyncLog>> getSyncLogs(@RequestParam(required = false) String status) {
        List<SyncLog> logs = status != null ? 
            syncLogMapper.findByStatus(status) : 
            syncLogMapper.findByStatus("SUCCESS"); // 默认查询成功的日志
        return ResponseEntity.ok(logs);
    }
    
    /**
     * 查询指定同步日志详情
     */
    @GetMapping("/logs/{id}")
    public ResponseEntity<SyncLog> getSyncLogById(@PathVariable Long id) {
        SyncLog syncLog = syncLogMapper.findById(id);
        return syncLog != null ? ResponseEntity.ok(syncLog) : ResponseEntity.notFound().build();
    }
}
```

## 17. 断路器工具类
```java
// CircuitBreakerUtil.java
package com.example.sync.util;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

/**
 * 简单的断路器实现
 */
public class CircuitBreakerUtil {
    
    private static final Logger logger = LoggerFactory.getLogger(CircuitBreakerUtil.class);
    
    private static final ConcurrentHashMap<String, CircuitBreaker> circuitBreakers = new ConcurrentHashMap<>();
    
    public static <T> T executeWithCircuitBreaker(String key, java.util.function.Supplier<T> supplier) {
        CircuitBreaker circuitBreaker = circuitBreakers.computeIfAbsent(key, k -> new CircuitBreaker());
        
        if (circuitBreaker.getState() == CircuitBreakerState.OPEN) {
            if (circuitBreaker.shouldAttemptReset()) {
                circuitBreaker.setState(CircuitBreakerState.HALF_OPEN);
            } else {
                throw new RuntimeException("Circuit breaker is OPEN for key: " + key);
            }
        }
        
        try {
            T result = supplier.get();
            circuitBreaker.recordSuccess();
            return result;
        } catch (Exception e) {
            circuitBreaker.recordFailure();
            throw e;
        }
    }
    
    private static class CircuitBreaker {
        private final int failureThreshold = 5; // 失败阈值
        private final long timeout = 60000; // 60秒超时
        
        private final AtomicInteger failureCount = new AtomicInteger(0);
        private final AtomicLong lastFailureTime = new AtomicLong(0);
        private volatile CircuitBreakerState state = CircuitBreakerState.CLOSED;
        
        public void recordSuccess() {
            failureCount.set(0);
            state = CircuitBreakerState.CLOSED;
        }
        
        public void recordFailure() {
            int failures = failureCount.incrementAndGet();
            lastFailureTime.set(System.currentTimeMillis());
            
            if (failures >= failureThreshold) {
                state = CircuitBreakerState.OPEN;
                logger.warn("Circuit breaker opened due to {} failures", failures);
            }
        }
        
        public boolean shouldAttemptReset() {
            return System.currentTimeMillis() - lastFailureTime.get() > timeout;
        }
        
        public CircuitBreakerState getState() {
            return state;
        }
        
        public void setState(CircuitBreakerState state) {
            this.state = state;
        }
    }
    
    private enum CircuitBreakerState {
        CLOSED, OPEN, HALF_OPEN
    }
}
```

## 18. 常量类
```java
// SyncConstants.java
package com.example.sync.constant;

public class SyncConstants {
    
    public static final String SYNC_TYPE_FULL = "FULL_SYNC";
    public static final String SYNC_TYPE_INCREMENTAL = "INCREMENTAL_SYNC";
    
    public static final String STATUS_RUNNING = "RUNNING";
    public static final String STATUS_SUCCESS = "SUCCESS";
    public static final String STATUS_FAILED = "FAILED";
    public static final String STATUS_PARTIAL_SUCCESS = "PARTIAL_SUCCESS";
    
    public static final int DEFAULT_BATCH_SIZE = 100;
    public static final int DEFAULT_RETRY_COUNT = 3;
    public static final int DEFAULT_TIMEOUT = 30000;
    
    public static final String HEADER_AUTHORIZATION = "Authorization";
    public static final String HEADER_USER_AGENT = "User-Agent";
    public static final String HEADER_CONTENT_TYPE = "Content-Type";
    
    private SyncConstants() {
        // 防止实例化
    }
}
```

## 19. 启动类
```java
// SyncApplication.java
package com.example.sync;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.retry.annotation.EnableRetry;

@SpringBootApplication
@EnableRetry
public class SyncApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(SyncApplication.class, args);
    }
}
```

## 20. 测试类示例
```java
// SyncServiceTest.java
package com.example.sync.service;

import com.example.sync.dto.SyncResultDto;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;

import javax.annotation.Resource;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
@ActiveProfiles("test")
class SyncServiceTest {
    
    @Resource
    private SyncService syncService;
    
    @Test
    void testSyncAllUsers() {
        SyncResultDto result = syncService.syncAllUsers();
        assertNotNull(result);
        assertTrue(result.isSuccess());
        assertTrue(result.getTotalCount() >= 0);
    }
    
    @Test
    void testSyncIncrementalUsers() {
        SyncResultDto result = syncService.syncIncrementalUsers();
        assertNotNull(result);
        assertTrue(result.isSuccess());
        assertTrue(result.getTotalCount() >= 0);
    }
}
```

## 21. 使用方式

### 启动应用
```bash
mvn spring-boot:run
```

### API调用示例
```bash
# 手动触发全量同步
curl -X POST http://localhost:8080/api/sync/full

# 手动触发增量同步  
curl -X POST http://localhost:8080/api/sync/incremental

# 查询同步日志
curl -X GET http://localhost:8080/api/sync/logs

# 异步全量同步
curl -X POST http://localhost:8080/api/sync/full/async
```

## 22. 主要特性

1. **完整的错误处理和重试机制**
2. **支持全量和增量同步**
3. **异步处理支持**
4. **详细的同步日志记录**
5. **定时任务调度**
6. **断路器模式防止服务雪崩**
7. **数据版本控制防止并发问题**
8. **RESTful API接口**
9. **完整的单元测试示例**
10. **灵活的配置管理**

这个模板提供了一个生产就绪的第三方接口数据同步解决方案，你可以根据具体需求进行调整和扩展。